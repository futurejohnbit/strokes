<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­†åŠƒä¿ å®¢ - çœŸå¯¦ç­†åŠƒç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            background: linear-gradient(135deg, #FFE5E5 0%, #E5F5FF 50%, #FFF5E5 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .game-container {
            background: white;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            padding: 30px;
            max-width: 850px;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #FF6B9D, #C561F5, #4E9FFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #FFD3E1, #C3E5FF);
            border-radius: 20px;
        }
        
        .score-item {
            text-align: center;
        }
        
        .score-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .score-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #FF6B9D;
        }
        
        #gameCanvas {
            border: 8px solid;
            border-image: linear-gradient(135deg, #FF6B9D, #C561F5, #4E9FFF, #50C878) 1;
            border-radius: 20px;
            display: block;
            margin: 0 auto;
            background: #FFF9E6;
            cursor: crosshair;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15), inset 0 2px 10px rgba(255,255,255,0.5);
        }
        
        .controls {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #E5F5FF, #FFE5F5);
            border-radius: 20px;
        }
        
        .control-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #4E9FFF;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .stroke-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .stroke-btn {
            padding: 15px;
            border: none;
            border-radius: 15px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        .stroke-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }
        
        .stroke-btn:active {
            transform: translateY(0);
        }
        
        .btn-heng { background: linear-gradient(135deg, #FFB3BA, #FF8E95); color: white; }
        .btn-shu { background: linear-gradient(135deg, #BAE1FF, #95CFFF); color: white; }
        .btn-pie { background: linear-gradient(135deg, #BAFFC9, #95FFB0); color: white; }
        .btn-na { background: linear-gradient(135deg, #FFD9B3, #FFC195); color: white; }
        .btn-dian { background: linear-gradient(135deg, #E0BBE4, #C99DD4); color: white; }
        .btn-gou { background: linear-gradient(135deg, #FFF4B3, #FFE995); color: white; }
        .btn-hengzhe { background: linear-gradient(135deg, #FFB3E6, #FF95D9); color: white; }
        .btn-hengzhegou { background: linear-gradient(135deg, #B3E5FF, #95D9FF); color: white; }
        
        .instructions {
            margin-top: 15px;
            padding: 15px;
            background: #FFF9E6;
            border-radius: 15px;
            font-size: 0.9em;
            color: #666;
        }
        
        .keyboard-hint {
            text-align: center;
            margin-top: 10px;
            font-size: 0.85em;
            color: #999;
        }
        
        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }
        
        .game-message.show {
            display: block;
            animation: bounceIn 0.5s;
        }
        
        @keyframes bounceIn {
            0% { transform: translate(-50%, -50%) scale(0.3); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .message-title {
            font-size: 2em;
            margin-bottom: 15px;
        }
        
        .message-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 20px;
        }
        
        .restart-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #FF6B9D, #C561F5);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 107, 157, 0.4);
        }
        
        /* micro:bit è¿æ¥æ ·å¼ */
        .microbit-connection {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #E8F5E9, #E3F2FD);
            border-radius: 20px;
            text-align: center;
        }
        
        .connect-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #4E9FFF, #2196F3);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        .connect-btn:active {
            transform: translateY(0);
        }
        
        .connection-status {
            margin-top: 15px;
            font-size: 1em;
            color: #666;
            transition: all 0.3s;
        }
        
        .stroke-indicator {
            display: none;
            margin-top: 15px;
            padding: 15px 30px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            border-radius: 15px;
            font-size: 1.3em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>ğŸ—¡ï¸ ç­†åŠƒä¿ å®¢å¤§å†’éšª ğŸ¨</h1>
        </div>
        
        <div class="score-board">
            <div class="score-item">
                <div class="score-label">ç•¶å‰æ¼¢å­—</div>
                <div class="score-value" id="currentChar">è¼‰å…¥ä¸­...</div>
            </div>
            <div class="score-item">
                <div class="score-label">ç•¶å‰ç­†åŠƒ</div>
                <div class="score-value" id="currentStroke">-/-</div>
            </div>
            <div class="score-item">
                <div class="score-label">å¾—åˆ†</div>
                <div class="score-value" id="score">0</div>
            </div>
        </div>
        
        <!-- micro:bit è¿æ¥åŒºåŸŸ -->
        <div class="microbit-connection">
            <button id="connectBtn" class="connect-btn" onclick="connectMicrobit()">
                ğŸ”Œ è¿æ¥ micro:bit
            </button>
            <div id="connectionStatus" class="connection-status">
                ğŸ’¡ æç¤ºï¼šè¿æ¥ micro:bit æ¥ç”¨çœŸå®åŠ¨ä½œæ§åˆ¶æ¸¸æˆ
            </div>
            <div id="strokeIndicator" class="stroke-indicator">
                âœ¨ è¯†åˆ«åˆ°ï¼šæ¨ª
            </div>
        </div>
        
        <div id="loadingMessage" class="loading">
            â³ æ­£åœ¨è¼‰å…¥æ¼¢å­—ç­†åŠƒæ•¸æ“š...
        </div>
        
        <canvas id="gameCanvas" width="750" height="550" style="display: none;"></canvas>
        
        <div class="controls">
            <div class="control-title">ğŸ® ç­†åŠƒæ§åˆ¶ (æ¨¡æ“¬ micro:bit è¼¸å…¥)</div>
            <div class="stroke-buttons">
                <button class="stroke-btn btn-heng" data-stroke="æ¨ª">æ©« â¡ï¸</button>
                <button class="stroke-btn btn-shu" data-stroke="ç«–">è± â¬‡ï¸</button>
                <button class="stroke-btn btn-pie" data-stroke="æ’‡">æ’‡ â†™ï¸</button>
                <button class="stroke-btn btn-na" data-stroke="æº">æº â†˜ï¸</button>
                <button class="stroke-btn btn-dian" data-stroke="ç‚¹">é» â¬‡ï¸</button>
                <button class="stroke-btn btn-gou" data-stroke="æ">å‹¾ â†©ï¸</button>
                <button class="stroke-btn btn-hengzhe" data-stroke="æ¨ªæŠ˜">æ©«æŠ˜ â¤µï¸</button>
                <button class="stroke-btn btn-hengzhegou" data-stroke="æ¨ªæŠ˜é’©">æ©«æŠ˜å‹¾ â¤´ï¸</button>
            </div>
            <div class="keyboard-hint">
                ğŸ’¡ ä¹Ÿå¯ä»¥ç”¨éµç›¤ï¼šH=æ©« S=è± P=æ’‡ N=æº D=é» G=å‹¾ Z=æ©«æŠ˜ K=æ©«æŠ˜å‹¾
            </div>
        </div>
        
        <div class="instructions">
            <strong>ğŸ“– éŠæˆ²èªªæ˜ï¼š</strong><br>
            1. å°ä¿ å®¢éœ€è¦æŒ‰ç…§æ­£ç¢ºçš„ç­†é †é€ƒé›¢æ¼¢å­—è¿·å®®<br>
            2. æ€ªç¸åœ¨å¾Œé¢è¿½è¶•ï¼Œè¦åœ¨è¢«æŠ“åˆ°å‰å®Œæˆæ‰€æœ‰ç­†åŠƒ<br>
            3. é¸æ“‡æ­£ç¢ºçš„ç­†åŠƒå‹•ä½œï¼Œä¿ å®¢å°±æœƒå‰é€²<br>
            4. âœ¨ ä½¿ç”¨çœŸå¯¦çš„æ¼¢å­—ç­†åŠƒè·¯å¾‘ï¼ˆä¾†è‡ª Make Me a Hanzi é …ç›®ï¼‰
        </div>
    </div>
    
    <div class="game-message" id="gameMessage">
        <div class="message-title" id="messageTitle">ğŸ‰</div>
        <div class="message-text" id="messageText">æ­å–œå®Œæˆï¼</div>
        <button class="restart-btn" onclick="restartGame()">ç¹¼çºŒæŒ‘æˆ°</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ç­†åŠƒé¡å‹æ˜ å°„è¡¨
        const strokeTypeMap = {
            'æ¨ª': ['heng', 'H', 'HENG'],
            'ç«–': ['shu', 'S', 'SHU'],
            'æ’‡': ['pie', 'P', 'PIE'],
            'æº': ['na', 'N', 'NA'],
            'ç‚¹': ['dian', 'D', 'DIAN'],
            'æ': ['gou', 'G', 'TI'],
            'æ¨ªæŠ˜': ['hengzhe', 'Z', 'HENGZHE'],
            'æ¨ªæŠ˜é’©': ['hengzhegou', 'K', 'HENGZHEGOU']
        };
        
        // micro:bit è“ç‰™è¿æ¥çŠ¶æ€
        let bluetoothDevice = null;
        let bluetoothCharacteristic = null;
        let isConnected = false;
        
        // è¿æ¥ micro:bit
        async function connectMicrobit() {
            try {
                document.getElementById('connectBtn').textContent = 'è¿æ¥ä¸­...';
                
                // è¯·æ±‚è“ç‰™è®¾å¤‡
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'BBC micro:bit' }],
                    optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e'] // Nordic UART Service
                });
                
                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
                bluetoothCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e'); // RX
                
                // å¼€å§‹æ¥æ”¶é€šçŸ¥
                await bluetoothCharacteristic.startNotifications();
                bluetoothCharacteristic.addEventListener('characteristicvaluechanged', handleMicrobitData);
                
                isConnected = true;
                document.getElementById('connectBtn').textContent = 'âœ… å·²è¿æ¥ micro:bit';
                document.getElementById('connectBtn').style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                document.getElementById('connectionStatus').textContent = 'ğŸ® æŒ¥åŠ¨ micro:bit æ¥ç©æ¸¸æˆï¼';
                document.getElementById('connectionStatus').style.color = '#4CAF50';
                
                showMessage('ğŸ‰ è¿æ¥æˆåŠŸï¼', 'micro:bit å·²è¿æ¥ï¼\nç°åœ¨å¯ä»¥ç”¨å®ƒæ¥æ§åˆ¶æ¸¸æˆäº†ï¼', null, false);
                
            } catch (error) {
                console.error('è¿æ¥å¤±è´¥:', error);
                document.getElementById('connectBtn').textContent = 'ğŸ”Œ è¿æ¥ micro:bit';
                document.getElementById('connectionStatus').textContent = 'âŒ è¿æ¥å¤±è´¥ï¼š' + error.message;
                document.getElementById('connectionStatus').style.color = '#FF6B9D';
                alert('è¿æ¥å¤±è´¥ï¼š' + error.message + '\n\nè¯·ç¡®ä¿ï¼š\n1. micro:bit å·²çƒ§å½•è“ç‰™ç¨‹åº\n2. micro:bit å·²å¼€æœº\n3. ä½¿ç”¨æ”¯æŒè“ç‰™çš„æµè§ˆå™¨ï¼ˆChrome/Edgeï¼‰');
            }
        }
        
        // å¤„ç† micro:bit å‘é€çš„æ•°æ®
        function handleMicrobitData(event) {
            const value = event.target.value;
            const decoder = new TextDecoder('utf-8');
            const data = decoder.decode(value).trim();
            
            console.log('æ”¶åˆ° micro:bit æ•°æ®:', data);
            
            // æ ¹æ®æ¥æ”¶åˆ°çš„ç¬”åˆ’ç±»å‹è§¦å‘æ¸¸æˆåŠ¨ä½œ
            const strokeMap = {
                'HENG': 'æ¨ª',
                'SHU': 'ç«–', 
                'PIE': 'æ’‡',
                'NA': 'æº',
                'DIAN': 'ç‚¹',
                'GOU': 'æ',
                'HENGZHE': 'æ¨ªæŠ˜',
                'HENGZHEGOU': 'æ¨ªæŠ˜é’©'
            };
            
            const strokeType = strokeMap[data];
            if (strokeType) {
                // æ˜¾ç¤ºè¯†åˆ«æç¤º
                showStrokeRecognition(strokeType);
                // è§¦å‘æ¸¸æˆåŠ¨ä½œ
                handleStroke(strokeType);
            }
        }
        
        // æ˜¾ç¤ºç¬”åˆ’è¯†åˆ«åŠ¨ç”»
        function showStrokeRecognition(strokeType) {
            const indicator = document.getElementById('strokeIndicator');
            indicator.textContent = `âœ¨ è¯†åˆ«åˆ°ï¼š${strokeType}`;
            indicator.style.display = 'block';
            indicator.style.animation = 'none';
            setTimeout(() => {
                indicator.style.animation = 'pulse 0.5s';
            }, 10);
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 1500);
        }
        
        // éŠæˆ²ç‹€æ…‹
        let gameState = {
            currentCharIndex: 0,
            currentStrokeIndex: 0,
            score: 0,
            heroPos: { x: 0, y: 0 },
            monsterPos: { x: 0, y: 0 },
            animationFrame: 0,
            gameOver: false,
            charactersData: [],
            loaded: false
        };
        
        // è¦å­¸ç¿’çš„æ¼¢å­—åˆ—è¡¨
        const charactersList = ['å¤§', 'äºº', 'æœ¨', 'ä¸­', 'ç”°', 'å£', 'æ—¥'];
        
        // è¼‰å…¥æ¼¢å­—æ•¸æ“š
        async function loadCharacterData(char) {
            try {
                const response = await fetch(`https://cdn.jsdelivr.net/npm/hanzi-writer-data@2.0/${char}.json`);
                if (!response.ok) throw new Error('Failed to load character data');
                const data = await response.json();
                return {
                    char: char,
                    strokes: data.strokes,
                    medians: data.medians
                };
            } catch (error) {
                console.error(`Failed to load character ${char}:`, error);
                return null;
            }
        }
        
        // åˆå§‹åŒ–æ‰€æœ‰æ¼¢å­—æ•¸æ“š
        async function initAllCharacters() {
            document.getElementById('loadingMessage').textContent = 'â³ æ­£åœ¨è¼‰å…¥æ¼¢å­—ç­†åŠƒæ•¸æ“š...';
            
            for (const char of charactersList) {
                const charData = await loadCharacterData(char);
                if (charData) {
                    gameState.charactersData.push(charData);
                }
            }
            
            if (gameState.charactersData.length > 0) {
                gameState.loaded = true;
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('gameCanvas').style.display = 'block';
                initGame();
            } else {
                document.getElementById('loadingMessage').textContent = 'âŒ è¼‰å…¥å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢';
            }
        }
        
        // SVG è·¯å¾‘è§£æå™¨ - ç°¡åŒ–ç‰ˆ
        function parseSVGPath(pathString) {
            const points = [];
            const commands = pathString.match(/[MmLlHhVvCcSsQqTtAaZz][^MmLlHhVvCcSsQqTtAaZz]*/g);
            
            let currentX = 0, currentY = 0;
            
            commands.forEach(cmd => {
                const type = cmd[0];
                const coords = cmd.slice(1).trim().split(/[\s,]+/).map(Number);
                
                switch(type) {
                    case 'M':
                        currentX = coords[0];
                        currentY = coords[1];
                        points.push({x: currentX, y: currentY});
                        break;
                    case 'L':
                        currentX = coords[0];
                        currentY = coords[1];
                        points.push({x: currentX, y: currentY});
                        break;
                    case 'Q':
                        // äºŒæ¬¡è²èŒ²æ›²ç·š - ç°¡åŒ–ç‚ºå¤šå€‹é»
                        const cpX = coords[0], cpY = coords[1];
                        const endX = coords[2], endY = coords[3];
                        for (let t = 0; t <= 1; t += 0.1) {
                            const x = (1-t)*(1-t)*currentX + 2*(1-t)*t*cpX + t*t*endX;
                            const y = (1-t)*(1-t)*currentY + 2*(1-t)*t*cpY + t*t*endY;
                            points.push({x, y});
                        }
                        currentX = endX;
                        currentY = endY;
                        break;
                    case 'C':
                        // ä¸‰æ¬¡è²èŒ²æ›²ç·š - ç°¡åŒ–ç‚ºå¤šå€‹é»
                        const cp1X = coords[0], cp1Y = coords[1];
                        const cp2X = coords[2], cp2Y = coords[3];
                        const end2X = coords[4], end2Y = coords[5];
                        for (let t = 0; t <= 1; t += 0.1) {
                            const x = Math.pow(1-t,3)*currentX + 3*Math.pow(1-t,2)*t*cp1X + 3*(1-t)*t*t*cp2X + t*t*t*end2X;
                            const y = Math.pow(1-t,3)*currentY + 3*Math.pow(1-t,2)*t*cp1Y + 3*(1-t)*t*t*cp2Y + t*t*t*end2Y;
                            points.push({x, y});
                        }
                        currentX = end2X;
                        currentY = end2Y;
                        break;
                }
            });
            
            return points;
        }
        
        // å°‡ SVG åº§æ¨™è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™ï¼ˆè·¯å¾‘è²¼åˆç­†åŠƒä¸­å¿ƒç·šï¼‰
        function transformStrokePoints(points) {
            const sourceSize = 900;
            const targetSize = 385; // å¾®èª¿å¤§å°ä»¥ç²¾ç¢ºå°é½Š
            const scale = targetSize / sourceSize;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const sourceCenterX = sourceSize / 2;
            const sourceCenterY = sourceSize / 2;
            
            // ç²¾ç´°èª¿æ•´åç§»é‡
            const offsetX = 3;
            const offsetY = -8;
            
            return points.map(p => ({
                x: centerX + (p.x - sourceCenterX) * scale + offsetX,
                y: centerY - (p.y - sourceCenterY) * scale + offsetY
            }));
        }
        
        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            if (!gameState.loaded || gameState.charactersData.length === 0) return;
            
            const charData = gameState.charactersData[gameState.currentCharIndex];
            
            // èª¿è©¦ï¼šè¨ˆç®—å¯¦éš›åº§æ¨™ç¯„åœ
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            charData.medians.forEach(median => {
                median.forEach(point => {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minY = Math.min(minY, point[1]);
                    maxY = Math.max(maxY, point[1]);
                });
            });
            console.log(`å­—ï¼š${charData.char} - Xç¯„åœ: ${minX} to ${maxX}, Yç¯„åœ: ${minY} to ${maxY}`);
            
            const firstStroke = charData.medians[0];
            const firstPoint = firstStroke[0];
            
            const transformedPoint = transformStrokePoints([{x: firstPoint[0], y: firstPoint[1]}])[0];
            gameState.heroPos = { ...transformedPoint };
            gameState.monsterPos = { x: transformedPoint.x - 100, y: transformedPoint.y };
            gameState.currentStrokeIndex = 0;
            updateUI();
            gameLoop();
        }
        
        // æ›´æ–° UI
        function updateUI() {
            const charData = gameState.charactersData[gameState.currentCharIndex];
            document.getElementById('currentChar').textContent = charData.char;
            document.getElementById('currentStroke').textContent = 
                `${gameState.currentStrokeIndex + 1}/${charData.strokes.length}`;
            document.getElementById('score').textContent = gameState.score;
        }
        
        // ç²å–ç­†åŠƒé¡å‹åç¨±
        function getStrokeTypeName(svgPath) {
            // ç°¡åŒ–çš„ç­†åŠƒé¡å‹åˆ¤æ–·
            if (svgPath.includes('H') || svgPath.includes('h')) return 'æ©«';
            if (svgPath.includes('V') || svgPath.includes('v')) return 'è±';
            
            // é€šéè·¯å¾‘æ–¹å‘åˆ¤æ–·
            const points = parseSVGPath(svgPath);
            if (points.length < 2) return 'é»';
            
            const start = points[0];
            const end = points[points.length - 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            if (Math.abs(dy) < 20) return 'æ©«';
            if (Math.abs(dx) < 20) return 'è±';
            if (dx < 0 && dy > 0) return 'æ’‡';
            if (dx > 0 && dy > 0) return 'æº';
            
            return 'å…¶ä»–';
        }
        
        // ç¹ªè£½è¿·å®®èƒŒæ™¯ï¼ˆä½¿ç”¨é‡è¤‡ç´‹ç†åœ–æ¡ˆï¼‰
        function drawMazeBackground() {
            const charData = gameState.charactersData[gameState.currentCharIndex];
            
            // å‰µå»ºé¦¬è³½å…‹è¿·å®®èƒŒæ™¯åœ–æ¡ˆ
            const patternCanvas = document.createElement('canvas');
            const patternSize = 60;
            patternCanvas.width = patternSize;
            patternCanvas.height = patternSize;
            const pctx = patternCanvas.getContext('2d');
            
            // ç¹ªè£½èƒŒæ™¯ç£šå¡Šåœ–æ¡ˆï¼ˆæ³¡æ³¡å ‚é¢¨æ ¼ï¼‰
            const colors = [
                ['#FFB3D9', '#FF8FC7'],
                ['#B3E5FF', '#8FD3FF'],
                ['#FFD9B3', '#FFC78F'],
                ['#D9B3FF', '#C78FFF']
            ];
            
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const colorPair = colors[(i + j) % colors.length];
                    const x = i * patternSize / 2;
                    const y = j * patternSize / 2;
                    const size = patternSize / 2;
                    
                    // ç¹ªè£½ç«‹æ–¹é«”ç£šå¡Š
                    pctx.save();
                    
                    // é™°å½±
                    pctx.fillStyle = 'rgba(0,0,0,0.15)';
                    pctx.fillRect(x + 2, y + 2, size - 2, size - 2);
                    
                    // ä¸»é«”æ¼¸è®Š
                    const grad = pctx.createLinearGradient(x, y, x + size, y + size);
                    grad.addColorStop(0, colorPair[0]);
                    grad.addColorStop(1, colorPair[1]);
                    pctx.fillStyle = grad;
                    pctx.fillRect(x, y, size - 2, size - 2);
                    
                    // 3Dæ•ˆæœé‚Šæ¡†
                    pctx.strokeStyle = shadeColor(colorPair[1], -30);
                    pctx.lineWidth = 1.5;
                    pctx.strokeRect(x, y, size - 2, size - 2);
                    
                    // é«˜å…‰
                    pctx.fillStyle = 'rgba(255,255,255,0.35)';
                    pctx.fillRect(x + 3, y + 3, size * 0.25, size * 0.25);
                    
                    pctx.restore();
                }
            }
            
            // å‰µå»ºåœ–æ¡ˆ
            const pattern = ctx.createPattern(patternCanvas, 'repeat');
            
            // å¡«æ»¿æ•´å€‹ç•«å¸ƒ
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // åœ¨ç­†åŠƒè·¯å¾‘ä¸Šæ¸…é™¤éšœç¤™ç‰©ï¼Œéœ²å‡ºé€šé“ï¼ˆé€šé“æœ¬èº«å½¢æˆå­—å½¢ï¼‰
            ctx.globalCompositeOperation = 'destination-out';
            
            charData.medians.forEach(median => {
                const points = transformStrokePoints(median.map(p => ({x: p[0], y: p[1]})));
                
                // ç¹ªè£½å¯¬é€šé“
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = 55; // å¢åŠ é€šé“å¯¬åº¦è®“å­—å½¢æ›´æ¸…æ™°
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            });
            
            ctx.globalCompositeOperation = 'source-over';
            
            // åœ¨é€šé“ä¸Šç¹ªè£½åœ°é¢ç´‹ç†ï¼ˆç±³è‰²åœ°é¢ï¼‰
            ctx.save();
            ctx.fillStyle = '#FFF4E0';
            
            charData.medians.forEach(median => {
                const points = transformStrokePoints(median.map(p => ({x: p[0], y: p[1]})));
                
                ctx.lineWidth = 52;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = '#FFF4E0';
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            });
            
            // æ·»åŠ åœ°é¢çš„ç´°å¾®ç´‹ç†
            ctx.globalAlpha = 0.08;
            ctx.strokeStyle = '#D4A574';
            ctx.lineWidth = 1;
            charData.medians.forEach(median => {
                const points = transformStrokePoints(median.map(p => ({x: p[0], y: p[1]})));
                
                for (let i = 0; i < points.length - 1; i++) {
                    if (i % 3 === 0) {
                        const p = points[i];
                        ctx.beginPath();
                        ctx.moveTo(p.x - 20, p.y);
                        ctx.lineTo(p.x + 20, p.y);
                        ctx.stroke();
                    }
                }
            });
            
            ctx.restore();
        }
        
        // åœ“è§’çŸ©å½¢è¼”åŠ©å‡½æ•¸
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        // é¡è‰²åŠ æ·±/æ¸›æ·¡
        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
        }
        
        // ç¹ªè£½å‡½æ•¸
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.loaded) return;
            
            // é¦–å…ˆç¹ªè£½è¿·å®®èƒŒæ™¯åœ–æ¡ˆï¼ˆé€šé“æœ¬èº«å½¢æˆå­—å½¢ï¼‰
            drawMazeBackground();
            
            const charData = gameState.charactersData[gameState.currentCharIndex];
            
            // ç¹ªè£½æ‰€æœ‰ç­†åŠƒè·¯å¾‘æŒ‡ç¤ºç·š
            charData.medians.forEach((median, index) => {
                const points = transformStrokePoints(median.map(p => ({x: p[0], y: p[1]})));
                
                if (index < gameState.currentStrokeIndex) {
                    // å·²å®Œæˆçš„ç­†åŠƒ - ç¶ è‰²ä¸­å¿ƒç·š
                    drawStrokePath(points, '#4CAF50', 10, 0.9);
                } else if (index === gameState.currentStrokeIndex) {
                    // ç•¶å‰ç­†åŠƒ - ç²‰ç´…è‰²é«˜äº®ä¸­å¿ƒç·š
                    drawStrokePath(points, '#FF6B9D', 12, 1);
                    // æ¨™è¨˜èµ·é»å’Œçµ‚é»
                    drawPoint(points[0], '#FFD700', 'èµ·', 18);
                    drawPoint(points[points.length - 1], '#4CAF50', 'çµ‚', 18);
                } else {
                    // æœªå®Œæˆçš„ç­†åŠƒ - ç°è‰²è™›ç·š
                    drawStrokePath(points, '#999', 8, 0.5, true);
                }
            });
            
            // ç¹ªè£½æ€ªç¸
            drawMonster(gameState.monsterPos.x, gameState.monsterPos.y);
            
            // ç¹ªè£½ä¿ å®¢
            drawHero(gameState.heroPos.x, gameState.heroPos.y);
            
            // ç¹ªè£½ç•¶å‰ç­†åŠƒæç¤ºå’Œå­—æç¤º
            const strokeType = getStrokeTypeName(charData.strokes[gameState.currentStrokeIndex]);
            ctx.fillStyle = '#FF6B9D';
            ctx.font = 'bold 26px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText(`ç¬¬ ${gameState.currentStrokeIndex + 1} ç­†ï¼š${strokeType}`, canvas.width / 2, 40);
            
            // åœ¨å³ä¸Šè§’é¡¯ç¤ºç•¶å‰æ¼¢å­—
            ctx.save();
            ctx.fillStyle = '#555';
            ctx.font = 'bold 60px STKaiti, KaiTi';
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 8;
            ctx.fillText(charData.char, canvas.width - 60, 60);
            ctx.restore();
            
            gameState.animationFrame++;
        }
        
        // ç¹ªè£½ç­†åŠƒè·¯å¾‘
        function drawStrokePath(points, color, width, alpha, dashed = false) {
            if (points.length < 2) return;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (dashed) {
                ctx.setLineDash([8, 4]);
            }
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.restore();
        }
        
        // ç¹ªè£½æ¨™è¨˜é»
        function drawPoint(pos, color, text, size) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, pos.x, pos.y);
            ctx.restore();
        }
        
        // ç¹ªè£½ä¿ å®¢ - ç²¾ç¾ç‰ˆ
        function drawHero(x, y) {
            const bounce = Math.sin(gameState.animationFrame * 0.1) * 3;
            
            ctx.save();
            ctx.translate(x, y + bounce);
            
            // é™°å½±æ•ˆæœ
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;
            
            // èº«é«” - æ¼¸è®Šè—è‰²
            const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
            bodyGradient.addColorStop(0, '#B3D9FF');
            bodyGradient.addColorStop(1, '#4E9FFF');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            
            // é ­å¸¶
            ctx.fillStyle = '#FF6B9D';
            ctx.fillRect(-22, -18, 44, 8);
            ctx.fillStyle = '#FFB3C6';
            ctx.fillRect(-22, -18, 44, 3);
            
            // åŠ - é‡‘è‰²æ¼¸è®Š
            const swordGradient = ctx.createLinearGradient(15, -15, 32, -32);
            swordGradient.addColorStop(0, '#FFF4B3');
            swordGradient.addColorStop(1, '#FFD700');
            ctx.strokeStyle = swordGradient;
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(15, -15);
            ctx.lineTo(30, -30);
            ctx.stroke();
            
            // åŠæŸ„
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(12, -12, 8, 4);
            
            // è‡‰éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(-5, -8, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›å¤–åœˆ
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-8, -2, 6, 0, Math.PI * 2);
            ctx.arc(8, -2, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç 
            ctx.fillStyle = '#2C3E50';
            ctx.beginPath();
            ctx.arc(-7, -2, 3, 0, Math.PI * 2);
            ctx.arc(9, -2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-6, -3, 1.5, 0, Math.PI * 2);
            ctx.arc(10, -3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // å¯æ„›çš„ç¬‘è‡‰
            ctx.strokeStyle = '#FF6B9D';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 5, 10, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            // è…®ç´…
            ctx.fillStyle = 'rgba(255, 182, 193, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-15, 8, 5, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(15, 8, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // ç¹ªè£½æ€ªç¸ - ç²¾ç¾ç‰ˆ
        function drawMonster(x, y) {
            const wobble = Math.sin(gameState.animationFrame * 0.15) * 2;
            
            ctx.save();
            ctx.translate(x, y + wobble);
            
            // é™°å½±
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 6;
            
            // èº«é«” - ç´«è‰²æ¼¸è®Š
            const bodyGradient = ctx.createRadialGradient(0, 0, 8, 0, 0, 30);
            bodyGradient.addColorStop(0, '#E0BBE4');
            bodyGradient.addColorStop(1, '#9C27B0');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            
            // èº«é«”ç´‹è·¯
            ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, 15 + i * 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // è§¸è§’åº•åº§
            ctx.fillStyle = '#9C27B0';
            ctx.beginPath();
            ctx.arc(-10, -25, 4, 0, Math.PI * 2);
            ctx.arc(10, -25, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // è§¸è§’
            ctx.strokeStyle = '#9C27B0';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-10, -25);
            ctx.lineTo(-10, -35);
            ctx.moveTo(10, -25);
            ctx.lineTo(10, -35);
            ctx.stroke();
            
            // è§¸è§’é ‚ç«¯ - ç²‰è‰²çƒ
            const antennaGradient = ctx.createRadialGradient(-10, -35, 2, -10, -35, 6);
            antennaGradient.addColorStop(0, '#FFB3D9');
            antennaGradient.addColorStop(1, '#FF4081');
            ctx.fillStyle = antennaGradient;
            ctx.beginPath();
            ctx.arc(-10, -35, 6, 0, Math.PI * 2);
            ctx.arc(10, -35, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // è§¸è§’é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(-12, -37, 2, 0, Math.PI * 2);
            ctx.arc(8, -37, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›å¤–åœˆ
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-10, 0, 8, 0, Math.PI * 2);
            ctx.arc(10, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç  - ç´…è‰²
            ctx.fillStyle = '#D32F2F';
            ctx.beginPath();
            ctx.arc(-10, 0, 5, 0, Math.PI * 2);
            ctx.arc(10, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            ctx.arc(-12, -2, 2.5, 0, Math.PI * 2);
            ctx.arc(8, -2, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // é‚ªæƒ¡çš„ç¬‘å®¹
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 8, 12, 0.1, Math.PI - 0.1);
            ctx.stroke();
            
            // å°–ç‰™
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(-8, 14);
            ctx.lineTo(-6, 18);
            ctx.lineTo(-4, 14);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(4, 14);
            ctx.lineTo(6, 18);
            ctx.lineTo(8, 14);
            ctx.closePath();
            ctx.fill();
            
            // èº«é«”é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.arc(-8, -10, 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // è™•ç†ç­†åŠƒè¼¸å…¥
        function handleStroke(strokeInput) {
            if (gameState.gameOver || !gameState.loaded) return;
            
            const charData = gameState.charactersData[gameState.currentCharIndex];
            const currentStrokeSVG = charData.strokes[gameState.currentStrokeIndex];
            const currentStrokeType = getStrokeTypeName(currentStrokeSVG);
            
            // æª¢æŸ¥è¼¸å…¥æ˜¯å¦åŒ¹é…ç•¶å‰ç­†åŠƒ
            let isCorrect = false;
            for (const [type, aliases] of Object.entries(strokeTypeMap)) {
                if (aliases.includes(strokeInput.toUpperCase()) || strokeInput === type) {
                    if (currentStrokeType === type || 
                        (type === 'æ¨ª' && currentStrokeType === 'æ©«') ||
                        (type === 'ç«–' && currentStrokeType === 'è±') ||
                        (type === 'æ’‡' && currentStrokeType === 'æ’‡') ||
                        (type === 'æº' && currentStrokeType === 'æº') ||
                        (type === 'ç‚¹' && currentStrokeType === 'é»')) {
                        isCorrect = true;
                        break;
                    }
                }
            }
            
            if (isCorrect) {
                // æ­£ç¢ºï¼ç§»å‹•ä¿ å®¢
                const median = charData.medians[gameState.currentStrokeIndex];
                const strokePoints = transformStrokePoints(median.map(p => ({x: p[0], y: p[1]})));
                animateHeroMovement(strokePoints);
                gameState.score += 100;
                
                setTimeout(() => {
                    gameState.currentStrokeIndex++;
                    
                    if (gameState.currentStrokeIndex >= charData.strokes.length) {
                        completeCharacter();
                    } else {
                        const nextMedian = charData.medians[gameState.currentStrokeIndex];
                        const nextPoint = transformStrokePoints([{x: nextMedian[0][0], y: nextMedian[0][1]}])[0];
                        gameState.heroPos = { ...nextPoint };
                        updateUI();
                    }
                }, 1000);
            } else {
                showWrongStroke();
            }
        }
        
        // å‹•ç•«ï¼šä¿ å®¢æ²¿è‘—ç­†åŠƒç§»å‹•
        function animateHeroMovement(points) {
            let step = 0;
            const totalSteps = 40;
            
            const interval = setInterval(() => {
                const progress = step / totalSteps;
                const index = Math.min(Math.floor(progress * (points.length - 1)), points.length - 2);
                const localProgress = (progress * (points.length - 1)) - index;
                
                gameState.heroPos = {
                    x: points[index].x + (points[index + 1].x - points[index].x) * localProgress,
                    y: points[index].y + (points[index + 1].y - points[index].y) * localProgress
                };
                
                step++;
                if (step > totalSteps) {
                    clearInterval(interval);
                }
            }, 20);
        }
        
        // é¡¯ç¤ºéŒ¯èª¤æç¤º
        function showWrongStroke() {
            const originalX = gameState.heroPos.x;
            let shake = 0;
            const shakeInterval = setInterval(() => {
                gameState.heroPos.x = originalX + Math.sin(shake) * 15;
                shake += 0.5;
                if (shake > Math.PI * 4) {
                    gameState.heroPos.x = originalX;
                    clearInterval(shakeInterval);
                }
            }, 16);
        }
        
        // å®Œæˆæ¼¢å­—
        function completeCharacter() {
            gameState.score += 500;
            
            if (gameState.currentCharIndex < gameState.charactersData.length - 1) {
                showMessage('ğŸ‰ å¤ªæ£’äº†ï¼', `ã€Œ${gameState.charactersData[gameState.currentCharIndex].char}ã€å®Œæˆï¼`, () => {
                    gameState.currentCharIndex++;
                    gameState.currentStrokeIndex = 0;
                    const nextCharData = gameState.charactersData[gameState.currentCharIndex];
                    const firstMedian = nextCharData.medians[0];
                    const firstPoint = transformStrokePoints([{x: firstMedian[0][0], y: firstMedian[0][1]}])[0];
                    gameState.heroPos = { ...firstPoint };
                    gameState.monsterPos = { x: firstPoint.x - 100, y: firstPoint.y };
                    updateUI();
                });
            } else {
                showMessage('ğŸ† æ­å–œé€šé—œï¼', `ä½ å®Œæˆäº†æ‰€æœ‰æ¼¢å­—ï¼\nç¸½åˆ†ï¼š${gameState.score}`, null, true);
                gameState.gameOver = true;
            }
        }
        
        // é¡¯ç¤ºæ¶ˆæ¯
        function showMessage(title, text, callback, isGameOver = false) {
            const messageDiv = document.getElementById('gameMessage');
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            messageDiv.classList.add('show');
            
            if (!isGameOver) {
                setTimeout(() => {
                    messageDiv.classList.remove('show');
                    if (callback) callback();
                }, 2000);
            }
        }
        
        // é‡æ–°é–‹å§‹
        function restartGame() {
            gameState.currentCharIndex = 0;
            gameState.currentStrokeIndex = 0;
            gameState.score = 0;
            gameState.gameOver = false;
            document.getElementById('gameMessage').classList.remove('show');
            initGame();
        }
        
        // éŠæˆ²å¾ªç’°
        function gameLoop() {
            draw();
            
            if (!gameState.gameOver && gameState.loaded) {
                const dx = gameState.heroPos.x - gameState.monsterPos.x;
                const dy = gameState.heroPos.y - gameState.monsterPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 45) {
                    gameState.monsterPos.x += dx * 0.001; // é™ä½é€Ÿåº¦å¾0.003åˆ°0.001
                    gameState.monsterPos.y += dy * 0.001;
                }
                
                if (distance < 55) {
                    gameState.gameOver = true;
                    showMessage('ğŸ˜± è¢«æŠ“åˆ°äº†ï¼', 'æ€ªç¸æŠ“åˆ°ä½ äº†ï¼\nå†è©¦ä¸€æ¬¡å§ï¼', null, true);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // æŒ‰éˆ•äº‹ä»¶
        document.querySelectorAll('.stroke-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const strokeType = btn.dataset.stroke;
                handleStroke(strokeType);
            });
        });
        
        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'h': 'heng',
                's': 'shu',
                'p': 'pie',
                'n': 'na',
                'd': 'dian',
                'g': 'gou',
                'z': 'hengzhe',
                'k': 'hengzhegou'
            };
            
            const strokeType = keyMap[e.key.toLowerCase()];
            if (strokeType) {
                handleStroke(strokeType);
            }
        });
        
        // å•Ÿå‹•éŠæˆ²
        initAllCharacters();
    </script>
</body>
</html>
